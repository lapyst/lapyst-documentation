:icons: font
:source-highlighter: rouge
:toc:
:toc-placement!:

= Procedures/Functions

toc::[]

In lapyst procedures and functions are the same thing.
To define a function we write:

[source,lapyst,website=norun]
----
def void myFunc()
    // ...
end
----

This defines the function `myFunc`. Its "body" is the code until the `end` keyword.
A body of a function is the code it holds. This is also the code that gets executed when we call / execute this function.

Let's write a simple example:

[source,lapyst,website=norun]
----
unit test;

@no_mangle
dec int printf(cstr fmt, ...); <1>

def void hello()
    printf("Hello, world!");
    return;
end
----
<1> Dont mind this; this is only needed so we can use `printf`; what it does will be explained later!

This function calls, when executed, the function `printf` which is a function that prints out text to the screen. But when we run the code above, nothing is get printed!

This is because we dont call our own function! So lets fix that:

[source,lapyst]
----
unit test;

@no_mangle
dec int printf(cstr fmt, ...);

def void hello()
    printf("Hello, world!");
    return;
end

def void main()
    hello();
    return;
end
----

When we now run this code, we should see the text 'Hello, world!' on the screen. You might ask whats the difference here, since we are just calling our `hello` function from another one called `main`, doesn't it need to be also be called to start executing? Well yes, but `main` is special: it's the so called entry-point. This means that it's automatically get called once your program starts!

NOTE: In previous examples (and in following ones), code might not be in functions, or the example dosnt have a `main` function. This is due to better readibility and the reader is supposed to call the functions themself from `main` or put the code into a proper function.

== Parameters / Arguments

Our first function is a bit boring, it dosnt do much than to group our code.
This can be changes with parameters! They allow a function to take arguments that can change the behaviour of the function. We've already used them: the `printf` function has arguments too: the string `"Hello, world!"`.

NOTE: Like variables, parameters also can be either typed or type-less.

[source,lapyst]
----
unit test;

@no_mangle
dec int printf(cstr fmt, ...);

def void good_morning(string name)
    printf("Good morning ${name}!"); <1>
    return;
end

def void main()
    good_morning("Mai");
    return;
end
----
<1> we use string interpolation here to insert the value of the `name` variable into our string

With this function we can now call `good_morning("Mai");` to get the text `Good morning Mai!` onto our screen! Sweet! But the truly great is we are not limited to only the string `"Mai"`. We can use any other string you like; thats the power of parameters.

== Return values

We now know how to write functions that group code and how we parameterize them so we can control the code it contains. But wouldn't be greate to also get something back from them? This is possible with return values!

Basically every function can return one value. As with all type related things in lapyst we can also decide to type it or not!

NOTE: We actually used returntypes already! They where the `void` before our function names in the examples above!

First the typed example:

[source,lapyst]
----
unit test;

@no_mangle
dec int printf(cstr fmt, ...);

def int add(int a, int b)
    return a + b;
end

def main()
    var int r = add(2, 4);
    printf("r: %d", r);
    return;
end
----

Lets explain the code above: we define here the function `add` which has two parameters as input: `a` and `b`, both of type `int`. We also return an `int` here; thats the `int` in paratheses right after the `def` keyword.

Theres also a new keyword: `return`. It is the keyword what actually lets us set the result, in our case this is the result of the expression `a + b`. Return also ends the execution of the function, meaning any code after it dosnt get executed.

To access the result we use the function like we would use any other expression, in the example above we use the function-call in an assignment for the variable `r`.

But this dosnt stop there; lapyst supports tuples as return types:

[source,lapyst]
----
def (int,int,int,int) arithmetic(int a, int b)
    return (a + b), (a - b), (a * b), (a / b);
end

z = arithmetic(2, 4); <1>

a,b,c,d = arithmetic(2, 4); <2>
----
<1> `z` holds the tuple
<2> here the tuple is destructed into four different variables

When there are less recievers than the tuple holds, the last reciever will be set to a tuple of the remaining values (if possible). If not, the remaining values are discarded.

== Variable arguments

Lets take a closer look to how printf can be used:

[source,lapyst]
----
var string name;
printf("Good morning %s", name);
----

The function actually itself allows formatting, meaning there are a special "syntax" you need to encode in your string in order for the function to then replace these with data you provide.

In the example above, the `%s` is the format for the first argument to be a string. Lucky for us `name` is one!

NOTE: This example has the same result as string interpolation but with one major difference, we now can store the format somewhere different where we have no access to the variable; we also can make the whole thing dynamic by allowing the format string to switch. This would allow mulitlingual output and much more!

But how does this function work? Lets start by looking at its declaration:

[source,lapyst]
----
dec printf(string format, ...);
----

The first parameter is an string, that makes sense, its the format we use. But after that are three dots `...` whats that? - Thats what we call variable arguments, or varargs for short.

They allow us to tell lapyst that the function allows any number of arguments after arguments before it. Important is that an vararg can only stand last in the list of parameters, and it can only exists one of them.

To access them we need to use a kind of workaround: lapyst only supports full access to the whole list of arguments given, not just the varargs. Thats what the `argument` keyword is for:

[source,lapyst]
----
def sum(int n, ...)
    printf(arguments)   // would print "[3, 5, 6, 7]"
end

sum(3, 5, 6, 7)
----

The `argument` keywords acts like an array; thus all operations of an array are supported.

== Overloading

Overloading describes the ability to define multiple functs that are named the same, but they differ in their function signature. A function signature is the combination of all what a function defines to the outside world: the name, the parameters, and in lapyst: the returntypes

[source,lapyst]
----
def combine(int a, int b)
    return (a + b);
end

def combine(string a, string b)
    return "${a} ${b}";
end
----

As seen above, we define two times the function `combine`, but since their parameters differ, they dont overlap and thus dosn't create an error. To call them we need to be sure to plug the right parameters in:

[source,lapyst]
----
combine(1, 2);  // will call combine(int a, int b)

combine("hello", "world");  // will call combine(string a, string b)
----

This might be hard to distingisch when using type-less variables, because then it's based on what the variable actually holds.

== Generics

Sometimes it might be handy to have the ability to even parameterize the types of your parameters / return would it? That what "type parameters", or more commonly known "generics" are for!

[source,lapyst]
----
def R myFunc[R, T](T a)
    // ...
end
----

We see here, that between arguments (round brackets) and name of the function, is a new portion of text: thats the generics! They're contained in square brackets and are seperated via a comma, just like parameters.

However we declare types here, we can use anywhere for this function: parameters, returntype or inside the functions body.

If we want an type parameter to require that it extends another one, simple use following syntax:

[source,lapyst]
----
def void myFunc[T => Fruit](T a) <1>
    // ...
end
----
<1> this function now accapts any type that extends 'Fruit'.

But we could also just type 'a' as 'Fruit' you might say. That would be right, but if you want more complex type constratits this dosnt suffice:

[source,lapyst]
----
def Fruit checkAndReturn(Fruit a)
    // do the check
    return a;
end
----
Here we want to return the same type of fruit we passed in, but the returntype always will just return a 'Fruit', not what we passed in!

If we use generics instead however:
[source,lapyst]
----
def T checkAndReturn[T => Fruit](T a)
    // do the check
    return a;
end
----

We still do the same; but lapyst will correctly set the returntype to the same we got from the parameter 'a'! This is important when a user of this functions wants to further use that returntype as the type it passed it to your function.
