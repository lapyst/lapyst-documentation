:icons: font
:source-highlighter: rouge
:toc:
:toclevels: 3
:toc-placement!:

= Syntax

This chapter covers the syntax of the lapyst language.

toc::[]

== Comments

In lapyst, line comments can begin either with `//` or `#` and run until the line ends (LN / `\n`). There are also mutline comments available which starts with `/&#42;` and ends with `&#42;/`:

[source,lapyst]
----
// this is a line not processed by the parser
# this line too

/*
 And here we have an whole region of the file
 that's not processed!
*/
----

I personaly believe the first thing one should learn in a new language is how to write comments. This can help newcomers to document what code is doing, outcomment code to test things and much much more.

Lapyst also supports doc-comments; a special form of comments where the standard toolset of lapyst searches for more information it then can use for documentational purposes. For more of that see Doc-Comments.

== The line terminator

This is an very-very special character: it tells lapyst that an portion of the code is complete and it can now "execute" it. This character is the semicolon `;`.

It's hard to explain this right at the start, you get it when we move further. The only thing to rember is that this character itself does not modify your data or anything. It's for lapyst to find yout when an portion of code ends and it can take it and do it's magic.

// Literals
include::syntax/literals.adoc[leveloffset=+1]

// Operators
include::syntax/operators.adoc[leveloffset=+1]

== Declaration of Variables

As we have written above: variables in lapyst need to be "declared", which means we must tell lapyst about there existence.

But for this we first need to learn about typed and non-typed variables:
- typed variables are typed (like their name implies) and can only hold data of their type For classes there is an extra case but we learn that in the chapter about classes.

- non-typed variables (sometimes also refered as type-less) are variables that don't care about what they are storing. You might heard this under the term "duck-typing".

We know now that there are two types, but what do they actually DO?
Well typed variables bring you the benefit that they also "check" the data you assign them to be of the correct type. This check is both done at compile time as well as runtime. The only "downside" of this is you cannot store arbitary data in them, but this is ok because typed variables gives us security that we indeed have data of an certain type stored.

If we do not want this, or need an looser "storage", one can use type-less variables. But be warned: they can (and will!) intruduce bugs to your code. Not without reason are languages that where initiali designed without types are begining now to intruduce an optional typed mode.

Now enough the words let the syntax speak:

[source,lapyst]
----
var int i;
----

This code above declares an variable named `i` of the type integer (`int`).
Remember `nil`: this variable is now in the "nothing" state!

[source,lapyst]
----
i == nil    // this would be `true`
----

Since we declared `i` now, we can "store" (assign) an integer to it:

[source,lapyst]
----
i = 12;
----

But we cannot store anything else in it:

[source,lapyst]
----
// all of the lines below will fail:
i = "hello";
i = true;
i = false;
i = 12.22;  // 12.22 is an float, so it dosnt fit here because we need an integer.
----

What we've used here as a type is an so calles native type. They are the most basic form of data and have all a literal to represent them:
- integer
- float
- string
- boolean
- regex

For more informations about all native types, their restrictions and more, see builtin types.

Here an full example:

[source,laypst]
----
var int i;
i = 12;

// tipp: you also can merge the both lines together
var int j = 12;
----

[NOTE]
====
You might have noticed the simecolons in the examples.
Let us take a look at the first two lines of the full example:

[source,laypst]
----
var int i;
i = 12;
----

The simecolon in the first line tells lapyst: 'Hey this statement is finished, you can process it now!' which in turn then has the result that the variable declaration gets effective.

The same as the second line: only this time its not an statement from the begin of the file, but rather since the last simecolon.
====

=== Constants

If Variables are one side of the medal, Constants are the other: both of them store data, but variables are variable, meaning we can change what we store in them. Constants on the other hand can only store one single thing, forever.

Because of this behaviour, constantants need an mandatory assignment in the declaration.

[source,lapyst]
----
const int a = 12;       // correct
const int b;            // incorrect, missing initializer
----

Another thing they that they distinguishes them from variables, is that they dont allow any form of assignment:

[source,lapyst]
----
const int a = 12;

a = 13;     // error
a += 2;     // also an error
----

=== Typeless

We now know how we declare typed variables and constants, but what about type-less?
Simple: just dont write the type!

[source,lapyst]
----
var a;
const b = 12;
----

This will create a type-less variable and/or constant.

[NOTE]
====
Type-less constants are possible but they have no benefit over typed constants, since we cannot store anything other than their initial value in them. This means type-less constants are more or less a shortcut for constants so we dosnt need to write the type out.
====

// Functions
include::syntax/functions.adoc[leveloffset=+1]

// Branching
include::syntax/branching.adoc[leveloffset=+1]

// Loops
include::syntax/loops.adoc[leveloffset=+1]

// Error handling
include::syntax/error_handling.adoc[leveloffset=+1]

== Templates / Classes

Lapyst is a so called Object-Oriented programming language. But what is an object? Short: everything is an object, but when we speak of object we typically mean user-defined objects. They are "containers" for data and simplify the handling of data like functions do for code.

Lapyst follows here the "role" or "behavior" pattern, meaning a class dosnt dictate to 100% how a object in lapyst should be build, but rather it defines one part of the object.

Lets look at a simple template:

[source,lapyst]
----
template Animal
    // ...
end
----

The `template` keyword starts a new template, it then follows the name of the template which is an identifier and follows the same rule as all identifiers.

To instantiate a new instance of this template, we use the `new` keyword:

[source,lapyst]
----
var Animal a = new Animal();
----

Also notice how the type of the variable is now the name of our template: this means we now typed our variable as an `Animal`, meaning we also get the same type-checks as for builtin types but now also for our custom defined one!

=== Fields

We now know how to write a template and how we create an instance of it, but we currently dont store anthing in it. Theres where fields come into play: they are like variables but they reside inside a instance of an template, while declared on the template itself:

[source,lapyst]
----
template Animal
    var int weight; <1>
end
----
<1> This defines a field with the name `weight` of type `int`.

With this field itself we cannot do much, since fields in lapyst can have an visibility, which defaults to private. This is also the case with the field we just created. So lets make it public:

[source,lapyst]
----
template Animal
    var int !weight; <1>
end
----
<1> The `!` before the name declares the field as public.

Now it's public so we can assign data to it and also read from it:

[source,lapyst]
----
var Animal a = new Animal();
a.weight = 12;
printf("weight: %d", a.weight); <1>
----
<1> This should print `weight: 12`.

Theres actually a 3rd type of visibility: protected. But for that we first need to understand inheritance.

=== Methods

Methods a like functions but they are bound to an template / object and operate on them.
We declare them inside the template like we would normal functions:

[source,lapyst]
----
template Animal
    
    def make_noise()
        // ...
    end

end
----

When then can simply call them like so:

[source,lapyst]
----
var Animal a = new Animal();
a.make_noise(); <1>
----
<1> This calls the `make_noise` method from the `Animal` template the instance stored in `a`.

Methods also supports the same parameter and return functionalities we know from functions.

// self keyword
include::syntax/templates/self.adoc[leveloffset=+2]

// constructor
include::syntax/templates/constructor.adoc[leveloffset=+2]

=== Inheritance

Templates are all cool but what if we have two templates, say `Cat` and `Dog` which have many things in common? It would be a bit tedious to write them both from scratch isn't it? Lucky for us that we have inheritance! It allows us to declare a "parent" template for each template which then inherit all fields and methods of the parent:

[source,lapyst]
----
template Animal

    var int weight;

    def make_noise()
        // ...
    end

end

template Dog use [Animal]
    // ...
end

template Cat use [Animal]
    // ...
end

var Cat = new Cat();
cat.weight = 11;
cat.make_noise();
----

Use see, with `use` we can declare the parent(s) of an template. Why plural you may ask? Because lapyst supports multi-inheritance:

[source,lapyst]
----
template Mammal
    // ...
end

template Fish
    // ...
end

template Dolphin use [Mammal, Fish]
    // ...
end
----

This makes it possible for the `Dolphin` template to inherit fields and methods from both `Mammal` and `Fish`.

=== Protected fields

As we quickly note when we talked about fields, there is a third level of visibility next to private and public: protected. But first lets look on how the other two behave with inheritance:

[source,lapyst]
----
template Animal
    var int weight;
    var int !height;
end

template Cat use [Animal]

    def show_fields()
        // this works, since 'height' is public
        printf("heigth: %d", self.height);

        // this dosn't work, since 'weight' is is
        // only visible to 'Animal' itself
        printf("weight: %d", self.weight);
    end

end
----

As we see, we have a bit of a problem here: private fields are only visible inside the template they are declared on, but public fields are not only accessible by templates that inherit from its parent but also for the complete outside world.

Then it's time for protected fields:

[source,lapyst]
----
template Animal
    var int *weight;
end

template Cat use [Animal]

    def show_fields()
        printf("weight: %d", self.weight);
    end

end
----
<1> The `&#42;` before the name declares the field as protected.

Protected means that only the class it's declared on and its "children" can access it.

In each other language that would be it, but lapyst takes the whole thing a step further: you can declare how many levels of inheritance a protected field is visible. This is done by the amount of asterix's (`&#42;`) before the fieldname:

[source,lapyst]
----
template Animal
    var int *weight;
    var int **height; <1>
end

template Cat use [Animal]
    // ...
end

template Tiger use [Cat]
    def show_fields()
        // dosnt work since the `weight` field is only visible for one level
        printf("weight: %d", self.weight);

        // work since the `height` field is visible to up to two levels
        printf("height: %d", self.height);
    end
end
----
<1> Notice how theres no whitespace between the `&#42;` itself and also between the `&#42;` and the name.

As shown above, the level is counted from the template that define the protection onwards.

include::syntax/templates/super.adoc[leveloffset=+2]
include::syntax/templates/generics.adoc[leveloffset=+2]

// Roles
include::syntax/roles.adoc[leveloffset=+1]

// Annotations
include::syntax/annotations.adoc[leveloffset=+1]

// Macros
include::syntax/macros.adoc[leveloffset+=1]