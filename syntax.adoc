:icons: font
:source-highlighter: rouge
:toc:
:toc-placement!:

= Syntax

This chapter covers the syntax of the lapyst language.

toc::[]

== Comments

In lapyst, line comments can begin either with `//` or `#` and run until the line ends (LN / `\n`). There are also mutline comments available which starts with `/&#42;` and ends with `&#42;/`:

[source,lapyst]
----
// this is a line not processed by the parser
# this line too

/*
 And here we have an whole region of the file
 that's not processed!
*/
----

I personaly believe the first thing one should learn in a new language is how to write comments. This can help newcomers to document what code is doing, outcomment code to test things and much much more.

Lapyst also supports doc-comments; a special form of comments where the standard toolset of lapyst searches for more information it then can use for documentational purposes. For more of that see Doc-Comments.

== The line terminator

This is an very-very special character: it tells lapyst that an portion of the code is complete and it can now "execute" it. This character is the simekolon `;`.

It's hard to explain this right at the start, you get it when we move further. The only thing to rember is that this character itself does not modify your data or anything. It's for lapyst to find yout when an portion of code ends and it can take it and do it's magic.

== Literals

The building blocks of every language, they express the native datatypes of an language.

=== Numbers

Numbers in lapyst are written like in pretty much every other language (this includes english this time!):

[source,lapyst]
----
12 <1>
23.22 <2>
----
<1> Integer (non-fractional number)
<2> Floatingpoint number (number with fractional part)

Floatingpoint numbers (or floats as we will call them from now on) are always Decimal based.

Integers on the other hand only defaults to the decimal representation. Lapyst include a bunch of others, each one with it's own prefix:

[source,lapyst]
----
1234567890 <1>
0x123456789ABCDEF0 <2>
0o12345670 <3>
0b10 <4>
----
<1> Decimal (10) based integer
<2> Hexa-decimal (16) based integer (prefix `0x`)
<3> Octal (8) based integer (prefix `0o`)
<4> Binary (2) based integer (prefix `0b`)

For readability lapyst also supports an `_` underscore between the letters of each number (but not in the prefix!):

[source,lapyst]
----
0b01000100_10000100 // this is valid
0_b0100010010000100 // this is not; underscore is inside prefix
----

=== Booleans

Booleans are a simple datatype to express truthiness, this means they can either be `true` or `false`. These are by the way also the keywords in lapyst for the both only valid states of an boolean:

[source,lapyst]
----
true    // also known as 'yes' or '1'
false   // also known as 'no' or '0'
----

=== Variables

Variables are to be honest not an literal in the sense they express an native datatype,
but its an buildingblock nontheless, and the most important too!

Variables in lapyst needs to be "declared" which means they dont exits when you dont tell lapyst about them. To know how to do this read Declaration of Variables. For now you only need to know they need to be declared. The name of an variable is also called an "identifier".


==== Identifiers

There are a few rules for a identifier:

- the name cannot be a keyword (such as `true`, `false` or `end`)
- they need to only have alphanumerical characters in them (or underscores)
- they cannot have an whitespace or an linebreak in them
- they cannot start with an number

=== Strings

Lapyst only supports one type of string literal: double-quoted.
Note: in lapyst all strings are multiline strings.

[source,lapyst]
----
"Hello, world!"

"Good morning, ${name}!" <1>
----
<1> This string uses interpolation, this means at the position of `${name}` the stringified value of the variable `name` is inserted.

Strings also allow for escape characters:
[source,lapyst]
----
"\n"    // line break
"\t"    // tabulator
"\r"    // cariage return
"\\"    // the character \ but since it's also used to denote escape
        // character we simply use them double to get the character itself.
----

=== Nil

Lapyst supports nullni-ness or rather nilni-ness, which means that variables can have a state of "nothing", where they hold... nothing. This is typically the case right after you decalred a variable but assignent nothing to it.

You can use the literal `nil` to check if a variable indeed holds nothing, or to reset an variable to this state of nothingness. This will also destroy objects an free them if neccessary.

[source,lapyst]
----
i === nil <1>
i = nil <2>
----
<1> checks if i has nothing in it. See Comparison operators on what `===` is.
<2> resets i to a state where it has nothing in it.

=== Regex

Regexes (or regular expressions) are in lapyst first-class datatypes.
This means they have their own syntax too: they work a little like strings, but they dont support interpolation. They do howerver support to be multiline.

The various flags for an regex can be expressed rigth after the regex itself.

[source,lapyst]
----
/^hello/
/abc/i      // case insensitive flag
----

For more information about regular expressions read the chapter about it here: Regular Expressions.

== Operators

If literals are the building blocks, operators are the cement of an language: they hold together the literals and ultimatly gives them their purpose, since they "operate" on data.

=== Assignments

Since variables that holds nothing are a bit useless, there is the assignment operator: it's live purpose is to simply give variables data they hold:

[source,lapyst]
----
i = 12; <1>
----
<1> `i` holds now the integer `12`

=== Arithemtic

The aritmetic group of operators are performing arithmetic operations.
They are typically supported by all numric types (intergers, floats).

[source,lapyst]
----
a + b       // addition
a - b       // subtraction
a * b       // multiplication
a / b       // division
a % b       // modulo
a ** b      // pow; calculates the power of `b` with the base `a`
----

They can also be combined with the assignment operator to do two things at a time: first they calculate with the content of the variable, then the result is stored in said variable.
Note that there always be must the operator first and then the assignment operator, and also that there are no spaces allowed between them!

[source,lapyst]
----
a += 1 <1>
----
<1> this first calculates `a + 1` and then stores the result in `a`. you also could write `a = a + 1` but it's a bit shorter and easier to read.

=== Comparison

This type of operator compares two things with each other and returns an boolean value as a result. They return `true` when the comparison succeeds, and `false` otherwise. When they return `true` depends on the operator itself.

[source,lapyst]
----
a == b  // this compares a with b and only returns true when
        // when both are the same; note however that this operator can be overwritten! <1>
        // for an true equal you should use the "true equal" operator below.

a === b // true equal. also checks if the type of both are the same. one of the few
        // operators that cannot be overwritten. <1>

a != b  // true when a and b are different. can also be overwritten like '==' <1>

a !== b // same as '===' is for '='; but this is for '!=='.
        // this means this also checks the type of both a and b.
        // this means also that this operator cannot be overwritten <1>

/*
    Comparisons typically supported by numeric types
*/

a > b   // checks if a is greater than b
a < b   // checks if a is lower than b
a >= b  // checks if a is greater or equal than b
a <= b  // checks if a is lower or equal than b

/*
    Comparisons typically supported by string-like types
*/
a =~ b  // compares a against an regex. this operator is the only one that dosnt
        // return a boolean, but rather `nil` on failure (which is falsy) and
        // an regex result object on success (which is truthy)

/*
    Logical comparison, typically supported by boolean types.
    All both of them are "lazy evaluated". Meaning it's only checked (and executed)
    what is neccessary. See the operators itself for more information what this means.
*/
a || b  // 'or'. true when one or the other is true. is also true when both of them are true.
        // lazy evaluation: if a is true, b isn't checked.

a && b  // 'and'. true when both inputs are true.
        // lazy evaluation: if a is false, b isn't checked.

/*
    Bitwise operation <2>. Typically supported by numeric types
*/
a << b  // shifts the value of 'a' by 'b' bits to the left
a >> b  // shifts the value of 'a' by 'b' bits to the right

/*
    Bitwise - logical operations <2>. Typicalls supported by both numeric and boolean types.
*/
a & b   // bitwise and. also works like a non-lazy-evaluated 'and'

a | b   // bitwise or. also works like a non-lazy-evaluated 'or'

a ^ b   // bitwise xor. true when one of the both inputs are true, false otherwise.
        // also means this is by definition not lazy-evaluated.
----
<1> operator overwriting / overloading
<2> how bitwise operation works

== Expressions

Expressions should be easy when you know math. Its simply a term or a chain of literals, variables, operators and functions:

[source,lapyst]
----
(12 + 2)
(21 - b)
(z * getNumber())
----

You migth notice the parenteses: they are used to "group" expressions together, which can be come handy if you need to change the presedence of operators.

The presedence of operators is the order in which they are executed, you might know this from math: Multiplication and division are calculated before addition and subtraction. Even in a expression like this: `1 + 2 * 3` (the correct result is 7 by the way). If we now want to have the addition be calculated first we need to use parenteses: `(1 + 2) * 3`, and now the result is 9!

== Declaration of Variables

As we have written above: variables in lapyst need to be "declared", which means we must tell lapyst about there existence.

But for this we first need to learn about typed and non-typed variables:
- typed variables are typed (like their name implies) and can only hold data of their type For classes there is an extra case but we learn that in the chapter about classes.

- non-typed variables (sometimes also refered as type-less) are variables that don't care about what they are storing. You might heard this under the term "duck-typing".

We know now that there are two types, but what do they actually DO?
Well typed variables bring you the benefit that they also "check" the data you assign them to be of the correct type. This check is both done at compile time as well as runtime. The only "downside" of this is you cannot store arbitary data in them, but this is ok because typed variables gives us security that we indeed have data of an certain type stored.

If we do not want this, or need an looser "storage", one can use type-less variables. But be warned: they can (and will!) intruduce bugs to your code. Not without reason are languages that where initiali designed without types are begining now to intruduce an optional typed mode.

Now enough the words let the syntax speak:

[source,lapyst]
----
var int i;
----

This code above declares an variable named `i` of the type integer (`int`).
Remember `nil`: this variable is now in the "nothing" state!

[source,lapyst]
----
i == nil    // this would be `true`
----

Since we declared `i` now, we can "store" (assign) an integer to it:

[source,lapyst]
----
i = 12;
----

But we cannot store anything else in it:

[source,lapyst]
----
// all of the lines below will fail:
i = "hello";
i = true;
i = false;
i = 12.22;  // 12.22 is an float, so it dosnt fit here because we need an integer.
----

What we've used here as a type is an so calles native type. They are the most basic form of data and have all a literal to represent them:
- integer
- float
- string
- boolean
- regex

For more informations about all native types, their restrictions and more, see builtin types.

Here an full example:

[source,laypst]
----
var int i;
i = 12;

// tipp: you also can merge the both lines together
var int j = 12;
----

[NOTE]
====
You might have noticed the simecolons in the examples.
Let us take a look at the first two lines of the full example:

[source,laypst]
----
var int i;
i = 12;
----

The simecolon in the first line tells lapyst: 'Hey this statement is finished, you can process it now!' which in turn then has the result that the variable declaration gets effective.

The same as the second line: only this time its not an statement from the begin of the file, but rather since the last simecolon.
====

=== Constants

If Variables are one side of the medal, Constants are the other: both of them store data, but variables are variable, meaning we can change what we store in them. Constants on the other hand can only store one single thing, forever.

Because of this behaviour, constantants need an mandatory assignment in the declaration.

[source,lapyst]
----
const int a = 12;       // correct
const int b;            // incorrect, missing initializer
----

Another thing they that they distinguishes them from variables, is that they dont allow any form of assignment:

[source,lapyst]
----
const int a = 12;

a = 13;     // error
a += 2;     // also an error
----

=== Typeless

We now know how we declare typed variables and constants, but what about type-less?
Simple: just dont write the type!

[source,lapyst]
----
var a;
const b = 12;
----

This will create a type-less variable and/or constant.

[NOTE]
====
Type-less constants are possible but they have no benefit over typed constants, since we cannot store anything other than their initial value in them. This means type-less constants are more or less a shortcut for constants so we dosnt need to write the type out.
====

== Procedures/Functions

In lapyst procedures and functions are the same thing.
To define a function we write:

[source,lapyst]
----
def myFunc() <1>
    // ...
end
----

This defines the function `myFunc`. Its "body" is the code until the `end` keyword.
A body of a function is the code it holds. This is also the code that gets executed when we call / execute this function.

Let's write a simple example:

[source,lapyst]
----
def hello()
    printf("Hello, world!");
end
----

This function calls, when executed, the function `printf` which is a function that prints out text to the screen. But when we run the code above, nothing is get printed! This is because we dont call our own function! So lets fix that:

[source,lapyst]
----
def hello()
    printf("Hello, world!");
end

hello();
----

When we now run this code, we should see the text 'Hello, world!' on the screen.

=== Parameters / Arguments

Our first function is a bit boring, it dosnt do much than to group our code.
This can be changes with parameters! They allow a function to take arguments that can change the behaviour of the function. We've already used them: the `printf` function has arguments too: the string `"Hello, world!"`.

NOTE: Like variables can parameters also be typed or type-less.

[source,lapyst]
----
def good_morning(string name)
    printf("Good morning ${name}!"); <1>
end
----
<1> we use string interpolation here to insert the value of the `name` variable into our string

With this function we can now call `good_morning("Mai");` to get the text `Good morning Mai!` onto our screen! Sweet! But the truly great is we are not limited to only the string `"Mai"`. We can use any other string you like, thats the power of parameters.

=== Return values

We now know how to write functions that group code and how we parameterize them so we can control the code it contains. But wouldn't be greate to also get something back from them? This is possible with return values!

Basically every function can return one (or more) values. As with all type related things in lapyst we can also decide to type it or not!

First the typed example:

[source,lapyst]
----
def (int) add(int a, int b)
    return a + b;
end

var int r = add(2, 4);
----

Lets explain the code above: we define here the function `add` which has two parameters as input: `a` and `b`, both of type `int`. We also return an `int` here; thats the `int` in paratheses right after the `def` keyword.

Theres also a new keyword: `return`. It is the keyword what actually lets us set the result, in our case this is the result of the expression `a + b`. Return also ends the execution of the function, meaning any code after it dosnt get executed.

To access the result we use the function like we would use any other expression, in the example above we use the function-call in an assignment for the variable `r`.

But this dosnt stop there; lapyst allows multiple return types:

[source,lapyst]
----
def (int,int,int,int) arithmetic(int a, int b)
    return (a + b), (a - b), (a * b), (a / b);
end

a,b,c,d = arithmetic(2, 4);
----

This function returns not one, not two but FOUR values! To retrieve the distrinct values, we need once again an assigment, but this time the left side are multiple variables, seperated by commas.

When there are less recievers than the function returns, the last reciever will set to an array of the remaining values (if possible). If not, the remaining values are discarded.

=== Variable arguments

Lets take a closer look to how printf can be used:

[source,lapyst]
----
var string name;
printf("Good morning %s", name);
----

The function actually itself allows formatting, meaning there are a special "syntax" you need to encode in your string in order for the function to then replace these with data you provide.

In the example above, the `%s` is the format for the first argument to be a string. Lucky for us `name` is one!

NOTE: This example has the same result as string interpolation but with one major difference, we now can store the format somewhere different where we have no access to the variable; we also can make the whole thing dynamic by allowing the format string to switch. This would allow mulitlingual output and much more!

But how does this function work? Lets start by looking at its declaration:

[source,lapyst]
----
dec printf(string format, ...);
----

The first parameter is an string, that makes sense, its the format we use. But after that are three dots `...` whats that? - Thats what we call variable arguments, or varargs for short.

They allow us to tell lapyst that the function allows any number of arguments after arguments before it. Important is that an vararg can only stand last in the list of parameters, and it can only exists one of them.

To access them we need to use a kind of workaround: lapyst only supports full access to the whole list of arguments given, not just the varargs. Thats what the `argument` keyword is for:

[source,lapyst]
----
def sum(int n, ...)
    printf(arguments)   // would print "[3, 5, 6, 7]"
end

sum(3, 5, 6, 7)
----

The `argument` keywords acts like an array; thus all operations of an array are supported.

== Branching

=== if-elif-else

The standard way of branching: "check if something is true and do one thing, if it's false do another". Lets look at an example to understand it better:

[source,lapyst]
----
var bool a;

# ...
# ... some code that changes a
# ...

if (a) then
    printf("hello ");
end
printf("world");
----

The code above creates an `if` statement that checks if `a` is true, and executes the block of code between `then` and `end` if it is. Otherwise it just resumes the code after the `end`.

NOTE: we have an `end` keyword here to, but dosnt we use it to tell lapyst where the end of an function is? Well yes, but actually no. You see, `end` truly only tells the end of an block of code. The beginning can be intruduced by multiple different statements. Its also important to know that these "code-blocks" can be nested.

There are multiple versions of if, lets look at them all in one big example:

[source,lapyst]
----
if (a) then
    // this code gets executed when 'a' is true
elsif (b) then
    // this code only gets executed when 'a' is not true, and 'b' is
elsif (c) then
    // as we see we can repeat elsif many times as we like...
    // just make sure they dont accidently check whats already been checked
else
    // this code is only executed when no other branch above was executed
end

if (a) printf("hello"); <1>

if (a) <2>
    printf("hello");

printf("world") if (b); <3>
----
<1> this is an prefix-if; it's works like an if but it cannot have elsif or else branches. It also can only have one line of code in its "block": all code until the next simecolon.
<2> this is also an prefix-if but the code for the "block" is in the next line.
<3> this is an so called postfix-if: the code before it gets executed only when the check of the if succeeds. This type of if also dosnt allow any elsif or else branches.

==== unless

The `unless` keyword works like an if, but reversed. It dosnt check for an true value but rather after an false value.

It supports nearly all forms that an if also supports; only an 'elsif' equivavelt hasnt been found yet.

// TODO: find elsif equivavelt for unless

=== ternary operator

The ternary opeator is less an operator than an statement: it is an very short form of an if-else statement. It also allows to return an value for an use in an expression or assignment, without needing to use `return`:

[source,lapyst]
----
msg = doomed ? "so long and thanks for all the fish" : "nice day";
----

The code above will put the string `"so long and thanks for all the fish"` into the variable `msg` if the other variable `doomed` is true; ans `"nice day"` otherwise.

=== Switch

Sometimes you need to write really, and I mean REALLY many elsif cases. That's a tedious process and I personally don't recommend it. But we have a cure for that: the switch statement.

[source,lapyst]
----
var string fruit;
# ...

switch fruit do <1>
case "apple": <2>
    shoot_with_arrow(User.TELL_WILLHELM);
    break; <3>
case "pear":
    fruit_compareWith(Fruit.Apple);
    break;
case "banana":
    myself_ask("why is the banana crooked?");
    break;
default: <4>
    kernel_panic("we just got a meltdown. or something similar.");
end
----
<1> This is the header, it declares that we want to inspect the value of `fruit`

<2> This is an case, it declares what value should trigger the execution of the code after the colon (`:`). Code is then executed onward. It will not stop when it's encounter an next `case`, but rather will "fall-through" and execute it's code as well and so on. For a "stop" of execution you'll need to use `break`.

<3> The `break` statement, it stops the execution and resumes the code after the `end` of the switch statement.

<4> With `default:` we can make an "default" branch which code gets executed if no other case above has matched. Think of it like the 'else' in an 'if'.

== Loops

=== While-Loops

While loops are the simpliest kind of loops: they continue the code in them until their condition is not true anymore.

For example:

[source,lapyst]
----
var int i = 0
while (i < 10) do
    // ...
    i += 1;
end
----

This while loop executes the code between the `do` and the `end` keyword until the condition (`i < 10`) is no longer true.

IMPORTANT: An while loop can also have the condtion `true`, which makes an loop that never ends! You need to use other features then to break out, for example `return`.

The loop above is an so called head-controlled loop, because the "controller" (the condition) as at the top of the loop, this means to that we always check at the beginning of an iteration if the condition is still true, when not we resume execution after the `end` keyword. This also means when we would set `i` to an initital value of `10`, the loop would never run a single time.

If you want a loop run at least a single time, you need an tail-controlled loop:

[source,lapyst]
----
var int i = 0
do
    // ...
    i += 1;
while (i < 10) end
----

This loops first runs the loop's body (from `do` to the `while`) and then checks if the condition is true, when it is its once again executes the loop's body, if not it simple resumes normal execution after the `end`.

=== for-loop / Iterative-Loops

Iterative loops characterized by the fact that they iterate over some sort of range. This can either be an numeric range, or an simple range of elements via an so called "enumerator" . Lapyst has syntax for both of them.

==== Numeric For-Loop

Let's start with the little more common one: the numeric range.

[source,lapyst]
----
for int i in 1 to 10 step 2 do
    // ...
end
----

This loop declares that the variable `i` should hold the current iteration number, which is of type `int`. The iteration itself should begin with 1 and stop at 10 (including 10) with an step-size of 2.

NOTE: In numeric based loops the iteration variable must be an numeric type.

We also can drop the `step 2` part; the loop then defaults to a stepsize of `1`:

[source,lapyst]
----
for int i in 1 to 10 do
    // ...
end
----

We also can drop the type of the iteration variable; lapyst then picks one suited for the numeric range:

[source,lapyst]
----
for i in 1 to 10 do
    // ...
end
----

==== Enumerating For-Loop

The enumerating for-loop is a litte more mightier than the numeric one: it supports multiple iteration variables, but lets start simple:

[source,lapyst]
----
for j in arr do
    // ...
end
----

This code declares an iteration variable `j` which type depends on the values that `arr` contains. If, for example, `arr` is an typed array with the type `array[int]` then `j` would be automatically a `int`. If `arr` is on the other hand an type-less array, then `j` would also be type-less thus enforcing to write the loop like this.

But we also can type `j` (if the enumerator `arr` can ensure that it's values only are one type):

[source,lapyst]
----
for int j in arr do
    // ...
end
----

Now this is how you enumerate over an array, but wat about maps? You use them simmilary, but here it works like the `return` keyword:

[source,lapyst]
----
for key,val in map do
    // ...
end
----

The enumerator of an map "returns" two things: the first one it the key, the second is the value for this key. So we can write `key,val in map` like we would wor an function that returns two things.

But it dosnt stop there: this type of loop also supports arbitary numbers of iteration variables like the an function can return. They also share the same feature when not enough varaibles to assign to are available: the last one gets assigned an array in which all the remaining returns are. So we could also write this:

[source,lapyst]
----
for entry in map do
    // ...
end
----

Since the enumerator of an map "returns" the key and the value, and we only give it one variable to assign to, it automatically makes an array where the first element is the key and the last element is the value, and assign it to the variable `entry`.

NOTE: to learn more about how to actually implement an enumerator see the documentation of the standard libary under Enumerator.

=== flow control

Since we learned before that there are loops that potentially never end such as this one:

[source,lapyst]
----
while true do
    // ...
end
----

We need some other forms of controlling the flow of the loop. The keywords you now learn can also been applied to nearly all type of loops.

==== break & next

With the `break;` keyword, you can "break-out" a loop and exit it entirely; the execution resumes then normaly after the end of the loop, like we would when we hit the condition:

[source,lapyst]
----
while true do
    var int i = get_int_from_somewhere();
    break if (i > 10); <1>
end
----
<1> This line is an postfix if, that executes `break` and thus ending the endless-loop when `i` is greater than 10.

But break only exits the loop entirely, what if we simply want to skip the rest of an iteration? Thats were `next` is for:

[source,lapyst]
----
for i in arr do
    next if (i > 10); <1>
    printf("%d\n", i);
end
----
<1> This code executes the `next` keyword if `i` is greater than 10.

The code above would only print out numbers in an array that are lower or equal to 10.

==== redo

The `redo` keyword is only used in iterational-loops (`for`-loops); it simply tells the loop not to use the next value on the next iteration but rather to redo the current iteration with the current value:

[source,lapyst]
----
for i in 1 to 10 do
    printf("Iteration %d\n", i);
    redo if (i == 3);
end
----

The code above would count to 3 and then infinitly redos the loop with the value `3`.
This in itself would not be very usefull but consider this example:

[source,lapyst]
----
for job in jobs do
    var status = job.execute();
    redo if (status != "success");
end
----

This code is a bit more usefull: it iterates over all jobs, executes them with `job.execute()` which returns the status of the job. We save this in the variable `status` and then call the `redo` if the status isn't `"success"`. Thus redoing the iteration with the same job, which then executes the job again. We effectivly programmed now a loop that retrys a job until it succeeds.

== Templates / Classes

Lapyst is a so called Object-Oriented programming language. But what is an object? Short: everything is an object, but when we speak of object we typically mean user-defined objects. They are "containers" for data and simplify the handling of data like functions do for code.

Lapyst follows here the "role" or "behavior" pattern, meaning a class dosnt dictate to 100% how a object in lapyst should be build, but rather it defines one part of the object.

Lets look at a simple template:

[source,lapyst]
----
template Animal
    // ...
end
----

The `template` keyword starts a new template, it then follows the name of the template which is an identifier and follows the same rule as all identifiers.

To instantiate a new instance of this template, we use the `new` keyword:

[source,lapyst]
----
var Animal a = new Animal();
----

Also notice how the type of the variable is now the name of our template: this means we now typed our variable as an `Animal`, meaning we also get the same type-checks as for builtin types but now also for our custom defined one!

=== Fields

We now know how to write a template and how we create an instance of it, but we currently dont store anthing in it. Theres where fields come into play: they are like variables but they reside inside a instance of an template, while declared on the template itself:

[source,lapyst]
----
template Animal
    var int weight; <1>
end
----
<1> This defines a field with the name `weight` of type `int`.

With this field itself we cannot do much, since fields in lapyst can have an visibility, which defaults to private. This is also the case with the field we just created. So lets make it public:

[source,lapyst]
----
template Animal
    var int !weight; <1>
end
----
<1> The `!` before the name declares the field as public.

Now it's public so we can assign data to it and also read from it:

[source,lapyst]
----
var Animal a = new Animal();
a.weight = 12;
printf("weight: %d", a.weight); <1>
----
<1> This should print `weight: 12`.

Theres actually a 3rd type of visibility: protected. But for that we first need to understand inheritance.

=== Methods

Methods a like functions but they are bound to an template / object and operate on them.
We declare them inside the template like we would normal functions:

[source,lapyst]
----
template Animal
    
    def make_noise()
        // ...
    end

end
----

When then can simply call them like so:

[source,lapyst]
----
var Animal a = new Animal();
a.make_noise(); <1>
----
<1> This calls the `make_noise` method from the `Animal` template the instance stored in `a`.

Methods also supports the same parameter and return functionalities we know from functions.

=== Inheritance

Templates are all cool but what if we have two templates, say `Cat` and `Dog` which have many things in common? It would be a bit tedious to write them both from scratch isn't it? Lucky for us that we have inheritance! It allows us to declare a "parent" template for each template which then inherit all fields and methods of the parent:

[source,lapyst]
----
template Animal

    var int weight;

    def make_noise()
        // ...
    end

end

template Dog use [Animal]
    // ...
end

template Cat use [Animal]
    // ...
end

var Cat = new Cat();
cat.weight = 11;
cat.make_noise();
----

Use see, with `use` we can declare the parent(s) of an template. Why plural you may ask? Because lapyst supports multi-inheritance:

[source,lapyst]
----
template Mammal
    // ...
end

template Fish
    // ...
end

template Dolphin use [Mammal, Fish]
    // ...
end
----

This makes it possible for the `Dolphin` template to inherit fields and methods from both `Mammal` and `Fish`.

==== Protected fields

As we quickly note when we talked about fields, there is a third level of visibility next to private and public: protected. But first lets look on how the other two behave with inheritance:

[source,lapyst]
----
template Animal
    var int weight;
    var int !height;
end

template Cat use [Animal]

    def show_fields()
        // this works, since 'height' is public
        printf("heigth: %d", self.height);

        // this dosn't work, since 'weight' is is
        // only visible to 'Animal' itself
        printf("weight: %d", self.weight);
    end

end
----

As we see, we have a bit of a problem here: private fields are only visible inside the template they are declared on, but public fields are not only accessible by templates that inherit from its parent but also for the complete outside world.

Then it's time for protected fields:

[source,lapyst]
----
template Animal
    var int *weight;
end

template Cat use [Animal]

    def show_fields()
        printf("weight: %d", self.weight);
    end

end
----
<1> The `&#42;` before the name declares the field as protected.

Protected means that only the class it's declared on and its "children" can access it.

In each other language that would be it, but lapyst takes the whole thing a step further: you can declare how many levels of inheritance a protected field is visible. This is done by the amount of asterix's (`&#42;`) before the fieldname:

[source,lapyst]
----
template Animal
    var int *weight;
    var int **height; <1>
end

template Cat use [Animal]
    // ...
end

template Tiger use [Cat]
    def show_fields()
        // dosnt work since the `weight` field is only visible for one level
        printf("weight: %d", self.weight);

        // work since the `height` field is visible to up to two levels
        printf("height: %d", self.height);
    end
end
----
<1> Notice how theres no whitespace between the `&#42;` itself and also between the `&#42;` and the name.

As shown above, the level is counted from the template that define the protection onwards.